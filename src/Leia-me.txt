Incluindo via CDN bootstrap:
Site: https://getbootstrap.com/

------------------------------------------------------- // -------------------------------------------------------

Para trabalhar com formulário temos que fazer o import do FormsModule.

No Angular, o `FormsModule` é um módulo que faz parte do pacote `@angular/forms` e é usado para trabalhar com 
formulários e realizar a vinculação de dados bidirecional (two-way data binding) entre os elementos do formulário 
e o modelo de dados da aplicação.

Quando você está construindo um aplicativo Angular com formulários, o `FormsModule` é uma dependência essencial que 
deve ser importada no módulo raiz ou em outros módulos onde você deseja usar formulários. Ele oferece diversas 
diretivas e recursos para simplificar o trabalho com formulários HTML e permite realizar a validação dos dados 
inseridos pelos usuários.

Alguns dos recursos fornecidos pelo `FormsModule` incluem:

1. Vinculação de dados bidirecional: Com as diretivas fornecidas pelo `FormsModule`, você pode vincular os dados do
 modelo de dados do Angular aos elementos do formulário. Isso significa que as alterações feitas nos elementos do 
 formulário são refletidas no modelo de dados e vice-versa.

2. Validação de formulários: O `FormsModule` suporta a validação de dados de entrada em tempo real. Você pode 
definir regras de validação para campos de formulário, como requerido, mínimo e máximo de caracteres, padrões 
personalizados, entre outros.

3. Rastreamento do estado de validação: As diretivas do `FormsModule` fornecem uma maneira de rastrear o estado de 
validação de cada campo de formulário. Isso permite que você saiba se o campo é válido, inválido, sujo (modificado 
pelo usuário) ou intocado.

4. Tratamento de eventos: O `FormsModule` também gerencia eventos como envio de formulário, clique em botões de 
envio e redefinição, e permite que você responda a esses eventos em seu código.

Depois de importar o módulo, você pode começar a usar as diretivas do `FormsModule`, como `ngModel`, `ngForm`, 
`ngSubmit`, entre outras, para criar e trabalhar com formulários no Angular.

Em resumo, o `FormsModule` é uma parte importante do Angular para trabalhar com formulários, fornecendo uma maneira 
conveniente de vincular dados e validar informações do usuário em seus aplicativos.

----------//----------
Anotações: NgModel e Formulário

As variaveis declaradas 'login' e 'senha' no 'app.component.ts' corresponde ao mesmo nome das variáveis declaradas
na nossa API do Spring Boot, exemplificando:
usuario = {login: '', senha: ''};

Para ligar essas variáveis no formulário vamos utilizar as diretivas ngmodel, exemplificando:
[(ngModel)]="usuario.login"
[(ngModel)]="usuario.senha"

A ação vai ser gerada pelo botão através do (click), exemplificando:
(click)="login()"

------------------------------------------------------- // -------------------------------------------------------

Vamos fazer agora a autenticação do JWT do Sprig Boot com o Angular API REST.
Analisando: Para fazer o login temos que passar pelo o nosso back-end e capturar o token, depois ligá-lo ao nosso
front-end (Angular), para só então poder ser enviado para a nossa API REST.

Para iniciar vamos criar um app-constants - Comandos no terminal:

PS C:\AngularComSpringBoot\ProjetoSpringBootApiComAngular> cd .\Projeto-Angular-REST\
PS C:\AngularComSpringBoot\ProjetoSpringBootApiComAngular\Projeto-Angular-REST> cd .\src\
PS C:\AngularComSpringBoot\ProjetoSpringBootApiComAngular\Projeto-Angular-REST\src> cd .\app\
PS C:\AngularComSpringBoot\ProjetoSpringBootApiComAngular\Projeto-Angular-REST\src\app> ng generate class AppConstants --skipTests=true 

O objetivo de criar esse arquivo é para vincular a porta 8080 e o context path 'projetospringrestapi' da nossa API Rest.

Código para analisar: 
public static get baseLogin(): string {return this.baseServidor + "projetospringrestapi/login"}

 -> get: A palavra-chave get é usada para definir um método getter. Um getter é um método especial que permite acessar o 
    valor de uma propriedade como se fosse uma propriedade de leitura.

 -> baseLogin: Este é o nome do getter. É a propriedade que será acessada como se fosse uma propriedade de leitura.

 -> (): string: Isso indica que o getter não tem parâmetros e que ele retorna uma string.

 ----------//----------

Para trabalhar com chamadas HTTP (requisição ajax) para servidores e consumir APIs RESTful vamos fazer um import 
HttpClientModule.

No Angular, o HttpClientModule é um módulo que faz parte do pacote @angular/common/http. Ele fornece um serviço 
chamado HttpClient, que é usado para fazer chamadas HTTP para servidores e consumir APIs RESTful ou outros recursos 
baseados em HTTP.

O HttpClientModule é uma melhoria em relação ao antigo HttpModule, que foi usado nas versões mais antigas do Angular. 
O HttpClientModule é baseado em Observables e oferece uma maneira mais moderna e poderosa de trabalhar com solicitações 
e respostas HTTP.

O HttpClient fornece uma variedade de métodos para diferentes tipos de solicitações HTTP, como get(), post(), put(), 
delete(), entre outros. Ele também permite que você envie cabeçalhos personalizados, parâmetros de consulta e corpos 
de requisição.

Lembre-se de que, para usar o HttpClient, você precisa adicionar o pacote @angular/common/http ao seu projeto, o que 
é normalmente feito por padrão ao criar um novo projeto Angular.

----------//----------

Vamos criar um service para implementar o login. Para criar vamos ao terminal - comandos:

PS C:\AngularComSpringBoot\ProjetoSpringBootApiComAngular> cd .\Projeto-Angular-REST\
PS C:\AngularComSpringBoot\ProjetoSpringBootApiComAngular\Projeto-Angular-REST> cd .\src\
PS C:\AngularComSpringBoot\ProjetoSpringBootApiComAngular\Projeto-Angular-REST\src> cd .\app\
PS C:\AngularComSpringBoot\ProjetoSpringBootApiComAngular\Projeto-Angular-REST\src\app> cd .\service\
PS C:\AngularComSpringBoot\ProjetoSpringBootApiComAngular\Projeto-Angular-REST\src\app\service> ng generate service LoginService --skipTests=true

Com o service criado vamos analisar esse código implementado: 
constructor(private http: HttpClient) { }

Esse script está definindo o construtor da classe HttpClient.

1. `constructor`: O construtor é um método especial de uma classe que é chamado automaticamente quando uma instância 
da classe é criada. É usado para inicializar a classe e seus membros.

2. `private http: HttpClient`: Aqui, estamos definindo um parâmetro chamado `http`, que tem o tipo `HttpClient`. A 
declaração `private` antes do nome do parâmetro indica que essa variável será um membro privado da classe. Ou seja, 
ela não será acessível fora da classe. 

Aqui, estamos usando o padrão de injeção de dependência do Angular. Quando você inclui um parâmetro no construtor de 
uma classe e especifica um tipo para esse parâmetro (como `HttpClient`), o Angular irá automaticamente fornecer uma 
instância daquele tipo quando criar uma instância da classe.

No caso específico do construtor apresentado, o `HttpClient` é um serviço do Angular usado para fazer chamadas HTTP 
a servidores e consumir APIs RESTful ou outros recursos baseados em HTTP. Ele é responsável por gerenciar e executar 
solicitações HTTP, como GET, POST, PUT, DELETE, etc.

Ao declarar o parâmetro `private http: HttpClient` no construtor, você está injetando o serviço `HttpClient` na 
classe. Isso permite que você use o `HttpClient` para fazer solicitações HTTP em qualquer método da classe. 

Esse padrão de injeção de dependência do Angular torna a criação de serviços e a interação com outras partes da 
aplicação mais fácil e flexível. Além disso, ajuda a facilitar a manutenção e o teste das classes, tornando-as menos 
acopladas e mais reutilizáveis.

----------//----------

Em 'app.component.ts vamos analisar' esse código implementado:
constructor(private loginService: LoginServiceService){}

Esse script está definindo o construtor dessa classe.

1. `constructor`: O construtor é um método especial de uma classe que é chamado automaticamente quando uma instância 
da classe é criada. É usado para inicializar a classe e seus membros.

2. `private loginService: LoginServiceService`: Aqui, estamos definindo um parâmetro chamado `loginService`, que tem 
o tipo `LoginServiceService`. A declaração `private` antes do nome do parâmetro indica que essa variável será um 
membro privado da classe. Ou seja, ela não será acessível fora da classe. Geralmente, é uma prática comum tornar 
serviços injetados em componentes ou outros serviços privados.

Quando uma instância dessa classe for criada, o Angular automaticamente criará uma instância do `LoginServiceService` 
e a injetará na propriedade `loginService`, tornando o serviço disponível para uso dentro dessa classe. Isso permite 
que você utilize o serviço `LoginServiceService` para executar suas operações e chamar métodos fornecidos por esse 
serviço.

----------//----------

No método login(usuario:any){...}

Vale ressaltar que os valores na tela não vem em formato de json (e sim em typescript), por exemplo, 
{login: "admin" e senha: "123"}

Já a nossa API Rest vem em formato de json, por exemplo, 
{"login": "admin" e "senha": "123"}

Repare os atributos vem entre aspas, lgo para resolver essa diferença teremos que manipular o código da seguinte maneira:
JSON.stringify(usuario)

Outro ponto que vale ressaltar que o acesso a login vem acompanhado com um token, porém antes teremos que resolver as 
incompatibilidades entre os servidores diferentes do back-end (API SpringBoot - 8080) e o front-end (angular - 4200) 
que são os cors. Os cors são gerado pelos navegadores e para resolver isso temos que fazer validações na API Rest
jogando como resposta os cors gerados no navegador. Por exemplo, na nossa API Rest SpringBoot serão tratados da 
seguinte maneira na classe de autenticação do token:

private void liberacaoCors(HttpServletResponse response) {
		if(response.getHeader("Access-Control-Allow-Origin") == null) {
			response.addHeader("Access-Control-Allow-Origin", "*");
		}
		
		if(response.getHeader("Access-Control-Allow-Headers") == null) {
			response.addHeader("Access-Control-Allow-Headers", "*");
		}
		
		if(response.getHeader("Access-Control-Request-Headers") == null) {
			response.addHeader("Access-Control-Request-Headers", "*");
		}
		
		// Liberando Cors para deletar o usuario
		if(response.getHeader("Access-Control-Allow-Methods") == null) {
			response.addHeader("Access-Control-Allow-Methods", "*");
		}
}


Voltando a parte do token, vale ressaltar que além dos dados (login e senha) do usuário vem com um token acompanhado,
é possível visualizar esse token através do código: 
console.info(JSON.parse(JSON.stringify(data)));

O token vem da seguinte maneira:
{Authorization: 'Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsIm…2MdpscpsxR2zgIpPYmfiMnc-DJEcYechoUcHu0pzb8rN0rSvQ'}

Podemos capturar até o Bearer com o código:
console.info(JSON.parse(JSON.stringify(data)).Authorization);
Vai vir assim: Bearer eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJhZG1pbiIsImV4cCI6MTY5MTEzMzI5M30.zpt5fWMOM6GWP7ApY9Av3hW7iq8kVcFPWMizv1fQH-KP7xNilfo9eoTaRs27eAKCvxKu7HxUsFIJ3wCGdqeq3Q

E podemos capturar apenas o token que é o que nos interessa, porém vale destacar que existe um espaço vazio entre a 
palavra 'Bearer' e o 'token' como pode ser visto no código da nossa API Rest Spring Boot: 
String token = TOKEN_PREFIX + " " + JWT; 

Vale ressaltar que o espaço vai ser utilizado o método split(). Portanto, para capturar apenas o token o código vai 
ser assim:
console.info(JSON.parse(JSON.stringify(data)).Authorization.split(' ')[1]);
